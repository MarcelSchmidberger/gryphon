<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>helpers/validator.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/arrayEquals.html">arrayEquals</a></li>
                                <li><a href="../classes/changeDClassAttrReferences.html">changeDClassAttrReferences</a></li>
                                <li><a href="../classes/changeDClassReferences.html">changeDClassReferences</a></li>
                                <li><a href="../classes/deleteExportTarget.html">deleteExportTarget</a></li>
                                <li><a href="../classes/deleteFragment.html">deleteFragment</a></li>
                                <li><a href="../classes/deleteScenario.html">deleteScenario</a></li>
                                <li><a href="../classes/DomainModelSchema.html">DomainModelSchema</a></li>
                                <li><a href="../classes/EventValidator.html">EventValidator</a></li>
                                <li><a href="../classes/ExportSchema.html">ExportSchema</a></li>
                                <li><a href="../classes/FragmentSchema.html">FragmentSchema</a></li>
                                <li><a href="../classes/GeneralValidator.html">GeneralValidator</a></li>
                                <li><a href="../classes/getAssociatedDomainModelFragment.html">getAssociatedDomainModelFragment</a></li>
                                <li><a href="../classes/getDomainModel.html">getDomainModel</a></li>
                                <li><a href="../classes/getDomainModels.html">getDomainModels</a></li>
                                <li><a href="../classes/getExportTargets.html">getExportTargets</a></li>
                                <li><a href="../classes/getFragment.html">getFragment</a></li>
                                <li><a href="../classes/getFragments.html">getFragments</a></li>
                                <li><a href="../classes/getFragmentStructure.html">getFragmentStructure</a></li>
                                <li><a href="../classes/getFragmentXML.html">getFragmentXML</a></li>
                                <li><a href="../classes/getScenario.html">getScenario</a></li>
                                <li><a href="../classes/getScenarios.html">getScenarios</a></li>
                                <li><a href="../classes/getValidateExportURL.html">getValidateExportURL</a></li>
                                <li><a href="../classes/getValidateFragment.html">getValidateFragment</a></li>
                                <li><a href="../classes/getValidateScenario.html">getValidateScenario</a></li>
                                <li><a href="../classes/OLCValidator.html">OLCValidator</a></li>
                                <li><a href="../classes/parseToBPMNObject.html">parseToBPMNObject</a></li>
                                <li><a href="../classes/parseToOLC.html">parseToOLC</a></li>
                                <li><a href="../classes/postAssociateDomainmodelToScenario.html">postAssociateDomainmodelToScenario</a></li>
                                <li><a href="../classes/postAssociateFragmentToScenario.html">postAssociateFragmentToScenario</a></li>
                                <li><a href="../classes/postDomainModel.html">postDomainModel</a></li>
                                <li><a href="../classes/postExportTarget.html">postExportTarget</a></li>
                                <li><a href="../classes/postFragment.html">postFragment</a></li>
                                <li><a href="../classes/postNewDomainModel.html">postNewDomainModel</a></li>
                                <li><a href="../classes/postNewExportTarget.html">postNewExportTarget</a></li>
                                <li><a href="../classes/postNewFragment.html">postNewFragment</a></li>
                                <li><a href="../classes/postNewScenario.html">postNewScenario</a></li>
                                <li><a href="../classes/postScenario.html">postScenario</a></li>
                                <li><a href="../classes/postScenarioExport.html">postScenarioExport</a></li>
                                <li><a href="../classes/ScenarioSchema.html">ScenarioSchema</a></li>
                                <li><a href="../classes/SoundnessValidator.html">SoundnessValidator</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/helpers.array.html">helpers.array</a></li>
                                <li><a href="../modules/helpers.json.html">helpers.json</a></li>
                                <li><a href="../modules/helpers.updaterefs.html">helpers.updaterefs</a></li>
                                <li><a href="../modules/helpers.validator.html">helpers.validator</a></li>
                                <li><a href="../modules/models.domainmodel.html">models.domainmodel</a></li>
                                <li><a href="../modules/models.export.html">models.export</a></li>
                                <li><a href="../modules/models.fragment.html">models.fragment</a></li>
                                <li><a href="../modules/models.scenario.html">models.scenario</a></li>
                                <li><a href="../modules/routes.domainmodel.html">routes.domainmodel</a></li>
                                <li><a href="../modules/routes.export.html">routes.export</a></li>
                                <li><a href="../modules/routes.fragment.html">routes.fragment</a></li>
                                <li><a href="../modules/routes.scenario.html">routes.scenario</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: helpers/validator.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;
var Scenario = require(&#x27;./../models/scenario&#x27;).model;
var parseToBPMNObject = require(&#x27;./json&#x27;).parseToBPMNObject;
var parseToOLC = require(&#x27;./json&#x27;).parseToOLC;

/**
 * @module helpers.validator
 */

/**
 * An validator that checks a fragment for structural soundness.
 *
 * @class SoundnessValidator
 * @type {{new(*=): {parseSequenceFlowReverse: (function(Array): {}), validateEverything: (function(): boolean), validateStartEvents: (function(*): boolean), parseIntoGraph: (function(*): {startEvents: Array, endEvents: Array, adjacencyList: {}, reverseList: {}}), parseNodes: (function(Array): Function), validateEndEvents: (function(*): boolean), validateSoundness: (function(*): boolean), parseSequenceFlow: (function(Array): {})}}}
 */
var SoundnessValidator = class {
    /**
     * Initiates the soundness validator with the given fragment.
     * @method constructor
     * @param bpmnObject
     */
    constructor(bpmnObject) {
        this.bpmnObject = bpmnObject;
        this.messages = [];
        this.graph = this.parseIntoGraph(bpmnObject);
    }

    /**
     * Creates an graph out of the given fragment, including all start end end-nodes and adjecency lists in both directions.
     * @methode parseIntoGraph
     * @param bpmnObject
     * @returns {{startEvents: Array, endEvents: Array, adjacencyList: {}, reverseList: {}}}
     */
    parseIntoGraph(bpmnObject) {
        var nodes = {};
        var nodes_reverse = {};

        var startEvents = [];
        if (bpmnObject.startEvent != undefined) {
            bpmnObject.startEvent.forEach(this.parseNodes(startEvents));
        }

        var endEvents = [];
        if (bpmnObject.endEvent != undefined) {
            bpmnObject.endEvent.forEach(this.parseNodes(endEvents));
        }

        if (bpmnObject.sequenceFlow != undefined) {
            nodes = this.parseSequenceFlow(bpmnObject.sequenceFlow);
            nodes_reverse = this.parseSequenceFlowReverse(bpmnObject.sequenceFlow)
        }
        if (bpmnObject.boundaryEvent != undefined) {
            bpmnObject.boundaryEvent.forEach(function(boundaryEvent){
                if (nodes[boundaryEvent.attachedToRef] == undefined) {
                    nodes[boundaryEvent.attachedToRef] = []
                }
                nodes[boundaryEvent.attachedToRef].push(boundaryEvent.id);

                if (nodes_reverse[boundaryEvent.id] == undefined) {
                    nodes_reverse[boundaryEvent.id] = []
                }
                nodes_reverse[boundaryEvent.id].push(boundaryEvent.attachedToRef)
            })
        }

        return {
            startEvents: startEvents,
            endEvents: endEvents,
            adjacencyList: nodes,
            reverseList: nodes_reverse
        }
    }

    /**
     * Returns a function that appends the ID of the element given to the returned function to the array gien to this
     * method.
     * @method parseNodes
     * @param node_list {Array}
     * @returns {Function}
     */
    parseNodes(node_list) {
        return function(element) {
            node_list.push(element.id)
        }
    }

    /**
     * Creates an adjacency list for the given sequence-flows.
     *
     * @methode parseSequenceFlow
     * @param sequenceFlow {Array} A list of sequence flows.
     * @returns {{}}
     */
    parseSequenceFlow(sequenceFlow) {
        var nodes = {};
        sequenceFlow.forEach(function(flow){
            if (nodes[flow.sourceRef] == undefined) {
                nodes[flow.sourceRef] = []
            }
            nodes[flow.sourceRef].push(flow.targetRef);
        });
        return nodes;
    }

    /**
     * Creates an adjacency list for the given sequence-flows. The sequence flows are reversed before read,
     * this method creates an reversed adjacency list.
     * @method parseSequenceFlowReverse
     * @param sequenceFlow {Array} A list of sequence flows.
     * @returns {{}}
     */
    parseSequenceFlowReverse(sequenceFlow) {
        var nodes = {};
        sequenceFlow.forEach(function(flow){
            if (nodes[flow.targetRef] == undefined) {
                nodes[flow.targetRef] = []
            }
            nodes[flow.targetRef].push(flow.sourceRef);
        });
        return nodes;
    }

    /**
     * Validates all given features. This function does not check for soundness if the start and end-event requirements
     * are not fulfilled.
     * @method validateEverything
     * @returns {boolean}
     */
    validateEverything() {
        if(this.validateStartEvents(this.graph.startEvents)&amp;&amp;this.validateEndEvents(this.graph.endEvents))
            return this.validateSoundness(this.graph);
        return false;
    }

    /**
     * Checks the amount of start events (There has to be exactly one)
     * @method validateStartEvents
     * @param startEvents
     * @returns {boolean}
     */
    validateStartEvents(startEvents) {
        if (startEvents.length != 1) {
            this.messages.push({
                &#x27;text&#x27;:&#x27;There must be only one start event&#x27;,
                &#x27;type&#x27;:&#x27;danger&#x27;
            });
            return false;
        }
        return true;
    };

    /**
     * Checks the amount of end events (There has to be at least one).
     * @method validateEndEvents
     * @param endEvents
     * @returns {boolean}
     */
    validateEndEvents(endEvents) {
        if (endEvents.length &lt;= 0) {
            this.messages.push({
                &#x27;text&#x27;:&#x27;There must be at least one end event&#x27;,
                &#x27;type&#x27;: &#x27;danger&#x27;
            });
            return false;
        }
        return true;
    }

    /**
     * Validates the given graph for structural soundness.
     * @method validateSoundness
     * @param graph
     * @returns {boolean}
     */
    validateSoundness(graph) {
        var search = function(node, visited, adjacencyList) {
            if (visited.indexOf(node) &gt;= 0) {
                return;
            }
            visited.push(node);
            if (node in adjacencyList) {
                adjacencyList[node].forEach(function(node){
                    search(node, visited, adjacencyList)
                });
            }
        };

        var res = [];
        graph.startEvents.forEach(function(event){
            var visited = [];
            search(event,visited,graph.adjacencyList);
            var err = false;
            for (var node in graph.adjacencyList) {
                if (graph.adjacencyList.hasOwnProperty(node)) {
                    err = err || (visited.indexOf(node) &lt; 0)
                }
            }
            res.push(!err);
        });

        graph.endEvents.forEach(function(event){
            var visited = [];
            search(event,visited,graph.reverseList);
            var err = false;
            for (var node in graph.reverseList) {
                if (graph.reverseList.hasOwnProperty(node)) {
                    err = err || (visited.indexOf(node) &lt; 0)
                }
            }
            res.push(!err)
        });

        var isReallyValid = true;
        res.forEach(function (el) {
            isReallyValid = isReallyValid &amp;&amp; el;
        });
        if (isReallyValid) {
            this.messages.push({
                &#x27;text&#x27;: &#x27;Your graph is structural sound!&#x27;,
                &#x27;type&#x27;: &#x27;success&#x27;
            });
            return true;
        } else {
            this.messages.push({
                &#x27;text&#x27;: &#x27;Your graph is not structural sound!&#x27;,
                &#x27;type&#x27;: &#x27;danger&#x27;
            });
            return false;
        }
    }
};


/**
 * A validator that checks for olc-conformance.
 *
 * @class OLCValidator
 * @type {{new(*, *): {validateDataObjectReference: (function(*)), createMapping: (function(Array, Array): Array), validateEverything: (function()), getDataObjectReference: (function(*): *), validateOSetDuplicates: (function(*)), validateIOSet: (function(*=, *=)), validateDataObjectFlow: (function())}}}
 */
var OLCValidator = class {
    /**
     * Initiates the OLC validator with the given fragment and  the available OLC-diagrams in this scenario.
     * @method constructor
     * @param bpmnObject
     * @param olc
     */
    constructor(bpmnObject,olc) {
        this.bpmnObject = bpmnObject;
        this.messages = [];
        this.olc = olc;
    }

    /**
     * Validates every feature of the given fragment.
     * @method validateEverything
     */
    validateEverything() {
        this.validateDataObjectFlow();
    }

    /**
     * Validates all tasks, message-receive-tasks and service tasks and their in and outputsets.
     * @method validateDataObjectFlow
     */
    validateDataObjectFlow() {
        if(this.bpmnObject.dataObjectReference != undefined) {
            this.bpmnObject.dataObjectReference.forEach(this.validateDataObjectReference.bind(this));
        }
        if(this.bpmnObject.dataObjectReference != undefined &amp;&amp; this.bpmnObject.task != undefined) {
            this.bpmnObject.task.forEach(this.validateTask(false));
        }
        if(this.bpmnObject.dataObjectReference != undefined &amp;&amp; this.bpmnObject.receiveTask != undefined) {
            this.bpmnObject.receiveTask.forEach(this.validateTask(true));
        }
        if(this.bpmnObject.dataObjectReference != undefined &amp;&amp; this.bpmnObject.serviceTask != undefined) {
            this.bpmnObject.serviceTask.forEach(this.validateTask(true));
        }
    }

    /**
     * Returns a function that validates an task for several OLC-restrictions. The function can be used in iterators.
     * @method validateTask
     * @param validateDuplicates {Boolean} If set on true, the task will be checked for duplicates in the outputset.
     * @returns {function(this:T)}
     */
    validateTask(validateDuplicates) {
        return function(task) {
            var iset = [];
            var oset = [];
            if (task.dataInputAssociation != undefined) {
                task.dataInputAssociation.forEach(function(dia){
                    iset.push(this.getDataObjectReference(dia[&#x27;sourceRef&#x27;][0]));
                }.bind(this));
            }
            if (task.dataOutputAssociation != undefined) {
                task.dataOutputAssociation.forEach(function(doa){
                    oset.push(this.getDataObjectReference(doa[&#x27;targetRef&#x27;][0]));
                }.bind(this));
            }
            if (validateDuplicates) {
                this.validateOSetDuplicates(oset);
            }
            this.validateIOSet(iset,oset);
        }.bind(this);
    }

    /**
     * Returns the dataobjectreference with the given ID
     * @method getDataObjectReference
     * @param dorefid
     * @returns {*}
     */
    getDataObjectReference(dorefid) {
        return this.bpmnObject.dataObjectReference.find(function(doref){
            return doref.id == dorefid;
        })
    };

    /**
     * Checks an outputset by the following rules:
     * 1. On automated activitys, there is just one outputset
     * @method validateOSetDuplicates
     * @param oset
     */
    validateOSetDuplicates(oset) {
        var output = [];
        oset.forEach(function(outputobject) {
            var dclass = outputobject[&#x27;griffin:dataclass&#x27;];
            if (output.indexOf(dclass) &gt;= 0) {
                this.messages.push({
                    &#x27;text&#x27;: &#x27;Invalid outputset. Only one possible Outputset is allowed. &#x27; + dclass + &#x27; is duplicate.&#x27;,
                    &#x27;type&#x27;: &#x27;danger&#x27;
                })
            }
            output.push(dclass);
        }.bind(this));
    }

    /**
     * Validates all dataobjectreferences in the given fragment by the following rules:
     * 1. No invalid (non-existing) dataclasses
     * 2. No invalid states according to the dataclasses olc.
     * @method validateDataObjectReference
     * @param doref
     */
    validateDataObjectReference(doref) {
        if (!(doref[&#x27;griffin:dataclass&#x27;] in this.olc)) {
            this.messages.push({
                &#x27;text&#x27;: &#x27;You referenced an invalid dataclass. (&#x27; + doref[&#x27;griffin:dataclass&#x27;] + &#x27;)&#x27;,
                &#x27;type&#x27;: &#x27;danger&#x27;
            })
        } else {
            if (this.olc[doref[&#x27;griffin:dataclass&#x27;]] != null &amp;&amp; !(doref[&#x27;griffin:state&#x27;] in this.olc[doref[&#x27;griffin:dataclass&#x27;]])) {
                this.messages.push({
                    &#x27;text&#x27;: &#x27;You referenced an invalid state (&#x27; + doref[&#x27;griffin:state&#x27;] + &#x27;) for data object &#x27; + doref[&#x27;griffin:dataclass&#x27;],
                    &#x27;type&#x27;: &#x27;danger&#x27;
                })
            }
        }
    }

    /**
     * Searches for classes that appear in the in- and the outputset and creates a list of the state transitions.
     * @method createMapping
     * @param iset {Array} The inputset
     * @param oset {Array} The outputset
     * @returns {Array}
     */
    createMapping(iset,oset) {
        var mapping = [];
        oset.forEach(function(outputo){
            var inputo = iset.find(function(inputo){
                return (outputo[&#x27;griffin:dataclass&#x27;] == inputo[&#x27;griffin:dataclass&#x27;]);
            });
            if (inputo != null) {
                mapping.push({
                    dataclass: inputo[&#x27;griffin:dataclass&#x27;],
                    instate: inputo[&#x27;griffin:state&#x27;],
                    outstate: outputo[&#x27;griffin:state&#x27;]
                });
            }
        });
        iset.forEach(function(inputo){
            var outputo = oset.find(function(outputo){
                return (outputo[&#x27;griffin:dataclass&#x27;] == inputo[&#x27;griffin:dataclass&#x27;]);
            });
            if (outputo != null) {
                mapping.push({
                    dataclass: inputo[&#x27;griffin:dataclass&#x27;],
                    instate: inputo[&#x27;griffin:state&#x27;],
                    outstate: outputo[&#x27;griffin:state&#x27;]
                });
            }
        });
        return mapping;
    }

    /**
     * Validates an in- and outputset of a given activity by the following rules:
     * 1. Check if all transitions are allowed in the assigned olc
     * @method validateIOSet
     * @param iset
     * @param oset
     */
    validateIOSet(iset, oset) {
        var mapping  = this.createMapping(iset,oset);
        mapping.forEach(function(iotuple){
            if (iotuple.dataclass in this.olc) {
                if (this.olc[iotuple.dataclass] != null) {
                    var olc = this.olc[iotuple.dataclass];
                    if (!(iotuple.instate in olc)) {
                        this.messages.push({
                            &#x27;text&#x27;: iotuple.instate + &#x27; -&gt; &#x27; + iotuple.outstate + &#x27; is not a valid state change according to the olc of the dataclass &#x27; + iotuple.dataclass,
                            &#x27;type&#x27;: &#x27;danger&#x27;
                        })
                    } else {
                        if (olc[iotuple.instate].indexOf(iotuple.outstate) &lt; 0) {
                            this.messages.push({
                                &#x27;text&#x27;: iotuple.instate + &#x27; -&gt; &#x27; + iotuple.outstate + &#x27; is not a valid state change according to the olc of the dataclass &#x27; + iotuple.dataclass,
                                &#x27;type&#x27;: &#x27;danger&#x27;
                            })
                        }
                    }
                }
            }
        }.bind(this))
    }
};

/**
 * Validates the given fragment for mistakes in event-references.
 *
 * @class EventValidator
 * @type {{new(*): {validateEventBasedGateways: (function()), getSequenceFlowTarget: (function(int): *), validateEvents: (function()), validateEverything: (function())}}}
 */
var EventValidator = class {
    /**
     * Initiates this validator with the given fragment
     * @mthod constructor
     * @param bpmnObject
     */
    constructor(bpmnObject) {
        this.bpmnObject = bpmnObject;
        this.messages = []
    }

    /**
     * Validates every event feature of the given fragment
     * @method validateEverything
     */
    validateEverything() {
        this.validateEvents();
        this.validateEventBasedGateways();
    }

    /**
     * Validates all events in the given fragment by the following rules:
     * 1. All message events need to have an event query.
     * 2. No other events but message and timer events are allowed.
     * 3. No throw-events
     * @method validateEvents
     */
    validateEvents() {
        if (this.bpmnObject.intermediateCatchEvent) {
            this.bpmnObject.intermediateCatchEvent.forEach(function(ev){
                var allowed_ev_types = [&#x27;messageEventDefinition&#x27;, &#x27;timerEventDefinition&#x27;];
                var found = false;
                allowed_ev_types.forEach(function(evtype){
                    found = found || ev[evtype] != null;
                }.bind(this));
                if (!found) {
                    this.messages.push({
                        &#x27;text&#x27;: &#x27;Currently all catch events but Timer and Event are not supported in chimera! Remove them to allow export.&#x27;,
                        &#x27;type&#x27;: &#x27;danger&#x27;
                    })
                }
                if (ev.hasOwnProperty(&#x27;messageEventDefinition&#x27;) &amp;&amp; (!ev.hasOwnProperty(&#x27;griffin:eventquery&#x27;) || ev[&#x27;griffin:eventquery&#x27;] == &quot;&quot;)) {
                    this.messages.push({
                        &#x27;text&#x27;: &#x27;Message-Events need a query-definition.&#x27;,
                        &#x27;type&#x27;: &#x27;danger&#x27;
                    });
                }
            }.bind(this));
        }
        if (this.bpmnObject.intermediateThrowEvent) {
            this.messages.push({
                &#x27;text&#x27;: &#x27;Currently all throw events are not supported in chimera! Remove them to allow export.&#x27;,
                &#x27;type&#x27;: &#x27;danger&#x27;
            })
        }
    }

    /**
     * Validates all event based gateways by the following rules:
     * 1. All events after an event based gateway need to have different event queries
     * @method validateEventBasedGateways
     */
    validateEventBasedGateways() {
        if (this.bpmnObject.eventBasedGateway) {
            this.bpmnObject.eventBasedGateway.forEach(function(gateway){
                if (gateway.outgoing) {
                    var queries_found = [];
                    gateway.outgoing.forEach(function(outgoing_ref){
                        var ev = this.getSequenceFlowTarget(outgoing_ref);
                        if (ev &amp;&amp; ev.hasOwnProperty(&#x27;messageEventDefinition&#x27;) &amp;&amp;
                            ev.hasOwnProperty(&#x27;griffin:eventquery&#x27;) &amp;&amp; ev[&#x27;griffin:eventquery&#x27;] !== &quot;&quot;) {
                            if (queries_found.indexOf(ev[&#x27;griffin:eventquery&#x27;]) &gt;= 0) {
                                this.messages.push({
                                    &#x27;text&#x27;: &quot;You&#x27;ve used the query (&quot; + ev[&#x27;griffin:eventquery&#x27;].substring(0,30) + &quot;...) twice after an event based gateway. This is invalid because it causes unpredictable behavior.&quot;,
                                    &#x27;type&#x27;: &#x27;danger&#x27;
                                })
                            } else {
                                console.log(&quot;query:&quot; + ev[&#x27;griffin:eventquery&#x27;]);
                                queries_found.push(ev[&#x27;griffin:eventquery&#x27;]);
                            }
                        }
                    }.bind(this))
                }
            }.bind(this));
        }
    }

    /**
     * Returns the target object of an sequence flow by the ID of the sequence flow.
     * @method getSequenceFlowTarget
     * @param seqflowid {int}
     * @returns {*}
     */
    getSequenceFlowTarget(seqflowid) {
        var seqs = this.bpmnObject.sequenceFlow.filter(function(seqflow){
            return (seqflow.id == seqflowid);
        });
        if (seqs.length == 0) {
            return null;
        } else {
            var seqflow = seqs[0];
            if (seqflow.targetRef.substring(0,22) == &#x27;IntermediateCatchEvent&#x27;) {
                var evs = this.bpmnObject.intermediateCatchEvent.filter(function(ev){
                    return (ev.id == seqflow.targetRef);
                });
                if (evs.length == 0) {
                    return null;
                } else {
                    return evs[0];
                }
            } else {
                return null;
            }
        }
    }
};

/**
 * A validator that is able to validate using multiple other validators.
 *
 * @class GeneralValidator
 * @type {{new(string, Function, array=): {validateWithSimpleValidator: (function(*)), parseOLCPaths: (function(Domainmodel)), validateEverything: (function())}}}
 */
var GeneralValidator = class {
    /**
     * Initiates a validator with the given fragment and the given validators.
     * @method constructor
     * @param fragment {string} The fragment that should be validated
     * @param initDone {function} A function that should get called when the DB-initiation is done.
     * @param validators {array} A list of Classes that should be used as validator (Event Soundness and OLC on Default)
     */
    constructor(fragment,initDone, validators) {
        if (validators == undefined) {
            validators = [EventValidator, SoundnessValidator, OLCValidator];
        }
        if (initDone == undefined) {
            initDone = function() {
                this.validateEverything();
            }
        }
        this.validators = validators;
        this.fragment = fragment;
        this.bpmnObject = parseToBPMNObject(fragment.content);
        this.messages = [];
        Scenario.findOne({fragments:fragment._id}).populate(&#x27;domainmodel&#x27;).exec(function(err, result) {
            if (result == null) {
                throw &quot;Can&#x27;t find domainmodel for fragment&quot;;
            }
            this.scenario = result;
            this.parseOLCPaths(result.domainmodel);
            initDone();
        }.bind(this))
    }

    /**
     * Validates every feature of the fragment that was loaded.
     * @method validateEverything
     */
    validateEverything() {
        this.validators.forEach(function(validator){
            if (validator == OLCValidator) {
                validator = new validator(this.bpmnObject, this.olc)
            } else {
                validator = new validator(this.bpmnObject);
            }
            this.validateWithSimpleValidator(validator);
        }.bind(this));
        console.log(&#x27;What&#x27;)
    }

    /**
     * Uses a simple validator (that needs to have an validateEverything() method) to validate the loaded fragment.
     * @method validateWithSimpleValidator
     * @param validator
     */
    validateWithSimpleValidator(validator) {
        validator.validateEverything();
        this.messages = this.messages.concat(validator.messages);
    }

    /**
     * This method creates adjacency lists for every dataclass according to it&#x27;s olc.
     * If there is no valid olc model for the dataclass (including at least one state) it&#x27;s invalid.
     * @method parseOLCPaths
     * @param domainmodel {Domainmodel}
     */
    parseOLCPaths(domainmodel) {
        this.olc = {};
        domainmodel.dataclasses.forEach(function(dclass){
            if (dclass.olc != undefined) {
                var olc = parseToOLC(dclass.olc);
                var adjlist = {};
                var namemap  = {};
                if (&#x27;state&#x27; in olc) {

                    olc[&#x27;state&#x27;].forEach(function(state){
                        if (&#x27;name&#x27; in state) {
                            namemap[state[&#x27;id&#x27;]] = state[&#x27;name&#x27;];
                        } else {
                            namemap[state[&#x27;id&#x27;]] = state[&#x27;id&#x27;];
                        }
                        adjlist[namemap[state[&#x27;id&#x27;]]] = [];
                    });

                    if (&#x27;sequenceFlow&#x27; in olc) {
                        olc[&#x27;sequenceFlow&#x27;].forEach(function(seqFlow){
                            if ((seqFlow[&#x27;sourceRef&#x27;] in namemap) &amp;&amp; (seqFlow[&#x27;targetRef&#x27;] in namemap)) {
                                adjlist[namemap[seqFlow[&#x27;sourceRef&#x27;]]].push(namemap[seqFlow[&#x27;targetRef&#x27;]]);
                            }
                        });
                        this.olc[dclass.name] = adjlist;
                    } else {
                        this.olc[dclass.name] = null;
                    }
                } else {
                    this.olc[dclass.name] = null;
                }
            } else {
                this.olc[dclass.name] = null;
            }
        }.bind(this))
    }
};

module.exports = {
    &#x27;Validator&#x27;: GeneralValidator
};
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
